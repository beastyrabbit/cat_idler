# Ralph Orchestrator Configuration
# Continuous generative feature loop: invent features, implement with TDD,
# create PRs, cycle back. Runs until manually stopped (Ctrl+C).

cli:
  backend: "claude"
  prompt_mode: "arg"

event_loop:
  prompt_file: "PROMPT.md"
  completion_promise: "MANUAL_STOP_ONLY"
  starting_event: "cycle.reset"
  max_iterations: 500
  max_runtime_seconds: 86400
  checkpoint_interval: 3

core:
  scratchpad: ".ralph/agent/scratchpad.md"
  specs_dir: ".ralph/specs/"
  guardrails:
    - "One PR per cycle, many cycles per run"
    - "No destructive git commands (no reset --hard, no force-push)"
    - "No PR creation until lint, typecheck, tests, and coverage pass"
    - "No task closure without concrete evidence"
    - "Fresh context each iteration; persist state via ralph tools task/memory"
    - "Always return to origin/main before starting a new feature branch"
    - "Never modify files unrelated to the current feature"
    - "Track completed features in memories for cross-cycle awareness"

memories:
  enabled: true
  inject: auto
  budget: 2000

tasks:
  enabled: true

events:
  cycle.reset:
    description: "Start of a new feature cycle"
    on_trigger: "Select and scope the next feature"
    on_publish: "Signal a new cycle is starting"

  feat.plan.ready:
    description: "Feature scope and acceptance criteria are ready"
    on_trigger: "Implement exactly the planned feature"
    on_publish: "Signal coding work can begin"

  feat.plan.blocked:
    description: "Planner cannot define executable scope"
    on_trigger: "Collect missing repo facts and recover"
    on_publish: "Signal blocked planning with reason"

  feat.skipped:
    description: "Feature was skipped (too complex, repeated failures, etc.)"
    on_trigger: "Record skip reason and cycle to next feature"
    on_publish: "Signal feature skip with reason"

  feat.code.ready:
    description: "Implementation is complete for review"
    on_trigger: "Perform code quality review"
    on_publish: "Signal code is ready for reviewer"

  feat.code.blocked:
    description: "Coder is blocked"
    on_trigger: "Inspect blocker and choose minimal recovery"
    on_publish: "Signal coding blocker"

  feat.review.pass:
    description: "Code quality review passed"
    on_trigger: "Start QA gate"
    on_publish: "Signal QA gate can start"

  feat.review.fixup:
    description: "Code needs targeted fixes from reviewer feedback"
    on_trigger: "Fix specific issues and resubmit"
    on_publish: "Signal fixup needed with details"

  feat.qa.pass:
    description: "All tests and evidence requirements passed"
    on_trigger: "Create PR"
    on_publish: "Signal PR creation gate can start"

  feat.qa.fail:
    description: "Quality gate failed"
    on_trigger: "Decide to retry or skip"
    on_publish: "Signal QA failure details"

  feat.pr.created:
    description: "PR successfully created"
    on_trigger: "Record completion and cycle to next feature"
    on_publish: "Signal PR created with URL"

  feat.pr.failed:
    description: "PR creation failed"
    on_trigger: "Diagnose and retry PR creation"
    on_publish: "Signal PR failure with reason"

hats:
  orchestrator:
    name: "Orchestrator"
    description: "Manages multi-feature lifecycle. Resets git state and cycles to next feature after each PR."
    triggers: ["feat.pr.created", "feat.skipped"]
    publishes: ["cycle.reset"]
    default_publishes: "cycle.reset"
    instructions: |
      ## ORCHESTRATOR MODE — Cycle Management

      You manage the continuous feature loop. After each PR or skipped feature,
      prepare for the next cycle.

      ### After a PR was created
      1. Record what was built:
         ```bash
         ralph tools memory add --type context "Completed: <feature title> — PR #<N> <url>"
         ```

      2. Reset to main for the next feature:
         ```bash
         git checkout main
         git pull origin main --ff-only
         ```

      3. Publish `cycle.reset` — the planner will invent the next feature.

      ### After a feature was skipped
      1. Record the skip:
         ```bash
         ralph tools memory add --type context "Skipped: <feature> — reason: <reason>"
         ```

      2. Check recent memories for consecutive skip count.
         If 3+ features skipped in a row, add a memory noting this and instruct
         the planner to pick something simpler in the next cycle.

      3. Reset to main and publish `cycle.reset`.

      ### DON'T
      - Don't implement features yourself
      - Don't skip the git reset between features
      - Don't emit any completion promise — the loop runs until manually stopped

  planner:
    name: "Planner"
    description: "Creatively invents and scopes the next feature by reading the codebase."
    triggers: ["cycle.reset", "feat.plan.blocked"]
    publishes: ["feat.plan.ready", "feat.plan.blocked", "feat.skipped"]
    default_publishes: "feat.plan.ready"
    instructions: |
      ## PLANNER MODE — Generative Feature Discovery

      You are the creative core. Your job is to INVENT a new feature that
      doesn't exist yet, scope it small, and hand it to the coder.

      ### Step 1: Understand what already exists
      ```bash
      ralph tools memory prime --budget 2000
      ```
      Then read the codebase to understand current systems:
      - `lib/game/` — list all modules and read key ones
      - `convex/schema.ts` — current data model
      - `types/game.ts` — type definitions
      - `app/game/newspaper/page.tsx` — current UI sections
      - Search for TODO/FIXME comments in the codebase

      ### Step 2: Invent a feature
      Think creatively. An idle game always has room for more:
      - Fix existing TODOs (wall defense, fertility blessing, etc.)
      - Add new newspaper sections (weather, personality, trends)
      - Add new game mechanics (seasons, relationships, territory)
      - Add UI polish (counters, indicators, animations)
      - Extend event/encounter systems (milestones, crises)
      - Add new pure game logic (trading, diplomacy, exploration)

      Check memories to avoid duplicating features already built this session.

      ### Step 3: Scope it small
      Apply the `feature-scope-small` skill:
      - 1-6 files changed max
      - Prefer pure functions in `lib/game/` with unit tests
      - UI changes go in existing newspaper sections
      - No schema migrations or new DB tables
      - No broad refactors

      ### Step 4: Create the branch
      ```bash
      git checkout main
      git pull origin main --ff-only
      git checkout -b feature/<kebab-case-name>
      ```

      ### Step 5: Create implementation tasks
      ```bash
      ralph tools task add "Write failing tests for <feature>" --priority 1
      ralph tools task add "Implement <feature> logic" --priority 2
      ralph tools task add "Wire <feature> into UI" --priority 3
      ```

      ### Step 6: Record the plan
      ```bash
      ralph tools memory add --type decision "Feature plan: <title> — <1-line description>"
      ```
      Update `.ralph/agent/scratchpad.md` with acceptance criteria and files.

      ### Step 7: Publish
      Publish `feat.plan.ready` with feature title, files, and acceptance criteria.

      ### If feature seems too complex
      Scope it down. If still too complex, publish `feat.skipped` with reason.
      The orchestrator will cycle back and you'll pick something easier.

  coder:
    name: "Coder"
    description: "Implements planned feature with TDD and tight scope control."
    triggers: ["feat.plan.ready", "feat.review.fixup", "feat.code.blocked", "feat.pr.failed"]
    publishes: ["feat.code.ready", "feat.code.blocked"]
    default_publishes: "feat.code.ready"
    instructions: |
      ## CODER MODE — TDD Implementation

      Implement only the planner-approved slice.

      ### Step 1: Prime context
      ```bash
      ralph tools memory prime --budget 2000
      ```
      Read `.ralph/agent/scratchpad.md` for the feature plan.

      ### Step 2: Implement using TDD
      1. Load skill: `ralph tools skill load tdd-implement-slice`
      2. RED: Write failing tests first
      3. GREEN: Implement minimal code to pass
      4. REFACTOR: Clean up while keeping tests green

      ### Step 3: Run verification
      ```bash
      bun run lint
      bun run typecheck
      bun run test
      ```

      ### Step 4: Commit
      ```bash
      git add <specific files>
      git commit -m "feat: <description>"
      ```

      ### Step 5: Update tasks and publish
      ```bash
      ralph tools task close <completed-task-id>
      ```
      Publish `feat.code.ready` with summary + changed files.

      ### If triggered by feat.review.fixup
      Read the reviewer's feedback from the event payload.
      Fix the specific issues and re-run verification.

      ### If triggered by feat.pr.failed
      Read the failure details from the event payload.
      Fix branch/push issues (e.g., rebase on main, resolve conflicts).
      Re-run verification and publish `feat.code.ready`.

      ### DON'T
      - Don't implement without tests
      - Don't change unrelated files
      - Don't add speculative features

  reviewer:
    name: "Reviewer"
    description: "Reviews correctness, scope discipline, and test quality. Does NOT edit code."
    triggers: ["feat.code.ready"]
    publishes: ["feat.review.pass", "feat.review.fixup"]
    default_publishes: "feat.review.pass"
    instructions: |
      ## REVIEWER MODE

      Review the implementation for quality and scope compliance.

      ### Checklist
      - Feature behavior matches acceptance criteria from scratchpad
      - No unrelated scope expansion
      - Tests cover real behavior and edge cases
      - Follows existing codebase patterns
      - No obvious regression risks

      ### Decision
      - All checks pass → publish `feat.review.pass`
      - Issues found → publish `feat.review.fixup` with specific feedback
        (max 2 fixup rounds, then pass with noted concerns)

      ### DON'T
      - Don't edit code yourself
      - Don't block on style nitpicks
      - Don't request more than 2 rounds of fixups

  qa_checker:
    name: "QA Checker"
    description: "Runs full quality gates and captures screenshot evidence."
    triggers: ["feat.review.pass"]
    publishes: ["feat.qa.pass", "feat.qa.fail"]
    default_publishes: "feat.qa.pass"
    instructions: |
      ## QA CHECKER MODE

      Execute mandatory checks and capture evidence.

      ### Required Checks
      1. Load skill: `ralph tools skill load qa-evidence-pack`
      2. Run ALL gates:
         ```bash
         bun run lint
         bun run typecheck
         bun run test
         bun run test:coverage
         ```

      ### Screenshot Evidence
      If the feature has UI changes:
      1. Capture at least 2 screenshots showing new behavior
      2. Upload: `curl -F'file=@<path>' https://0x0.st`
      3. Fallback: store under `docs/pr-assets/<branch>/`

      ### Decision
      - ALL checks pass → publish `feat.qa.pass` with evidence summary
      - Any check fails → publish `feat.qa.fail` with failure details

  qa_retry:
    name: "QA Retry Handler"
    description: "Handles QA failures by retrying or skipping."
    triggers: ["feat.qa.fail"]
    publishes: ["feat.code.blocked", "feat.skipped"]
    default_publishes: "feat.code.blocked"
    instructions: |
      ## QA RETRY MODE

      A quality gate failed. Decide whether to retry or skip.

      ### Step 1: Check retry count
      Read memories to see how many times this feature has failed QA.
      ```bash
      ralph tools memory prime --budget 500
      ```

      ### Step 2: Decide
      - If this is the 1st or 2nd failure:
        1. Record: `ralph tools memory add --type fix "QA retry #N for <feature>: <failure>"`
        2. Publish `feat.code.blocked` with the QA failure details — the coder will fix and retry
      - If this is the 3rd failure:
        1. Record: `ralph tools memory add --type context "Skipping <feature> after 3 QA failures"`
        2. Publish `feat.skipped` with reason "exceeded QA retry limit"

  pr_creator:
    name: "PR Creator"
    description: "Creates a PR with German explanation and evidence."
    triggers: ["feat.qa.pass"]
    publishes: ["feat.pr.created", "feat.pr.failed"]
    default_publishes: "feat.pr.created"
    instructions: |
      ## PR CREATOR MODE

      Create a pull request for the completed feature.

      ### Step 1: Push the branch
      ```bash
      git push -u origin <branch-name>
      ```

      ### Step 2: Create the PR
      1. Load skill: `ralph tools skill load pr-german-template`
      2. PR body must include:
         - German explanation of the feature
         - Test/check results
         - Screenshot evidence (0x0 URLs or repo paths)
         - Known limitations

      ### Step 3: Record and publish
      ```bash
      ralph tools memory add --type context "PR created: #<N> <title> — <url>"
      ralph tools task close <feature-task-id>
      ```
      Publish `feat.pr.created` with PR URL and feature title.

      ### If PR creation fails
      Publish `feat.pr.failed` with exact failure details.
      The coder will get a chance to fix branch/push issues.

      ### DON'T
      - Don't emit any completion promise
      - Don't merge the PR
      - Don't start the next feature — the orchestrator handles cycling
